/* Copyright 2017-2019, Senjo Org. Denis Rezvyakov aka Dinya Feony Senjo.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 */
package org.senjo.conveyor;

import static org.senjo.basis.Base.*;
import static org.senjo.support.LogEx.*;

import java.util.HashSet;
import org.senjo.annotation.*;
import org.senjo.basis.ABasket;
import org.senjo.basis.ABasketSync;
import org.senjo.basis.Gateway;

/** Управляющий механизм для всех конвейеров. Позволяет корректно и в правильном порядке
 * завершить работу всех конвейеров. Соответственно, хранит все запущенные экземпляры
 * конвейеров, хранит их зависимости друг от друга (пока не реализовано), управляет
 * их завершением, соблюдает порядок закрытия (пока нет). Хранит число запущенных конвейеров
 * и следит за ним в момент завершения работы, чтобы все конвейеры завершились, иначе
 * выводит в журнал сообщение об ошибке завершения работы.
 * Алгоритм завершения работы конвейеров:
 *  1. Сначала подаёт сигнал подготовки к закрытию, потом каждый конвейер сообщает Father'у
 *     что его очередь пуста, или снова появились данные; в порядке зависимости старшим
 *     конвейерам подаёт второй сигнал завершения работы и так по цепочке зависимостей
 *     к самым младшим, пока не остановятся все корвейеры.
 *  2. Подаёт первый сигнал, а второй не подаёт. Просто ждёт, когда все очереди всех
 *     конвейеров опустошатся.
 *  3. Не подаёт первый сигнал, а сразу в порядке зависимости подаёт сингал завершения
 *     и ждёт, когда конвейер остановится, чтобы также завершить следующий конвейер.
 * 
 * В принципе код можно статически внедрить и в Conveyor, но нагляднее он будет смотреться
 * в виде Singleton'а.
 * 
 * @author Denis Rezvyakov aka Dinya Feony Senjo
 * @version create 2017-10, change 2019-03-14 */
final class Father extends ABasketSync {
	static final Father father = new Father();

/*TODO Есть задумка переименовать Father в Surveyor. Father не очень подходит для этого
 * модуля, т.к. он сам не порождает, не назначает, не обучает, не настраивает и никак
 * влияет на объекты, а только наблюдает за ними и закрывает в нужный момент. С другой
 * стороны, в дальнейшем ему добавится миссия приглядывать за линиями конвейеров и задачами
 * в них, чтобы сбрасывать зависшие конвейерные линии. Но и эта миссия подходит обоим. */

	final HashSet<AConveyor> hash = new HashSet<>();
	int awaiting = -1;

	final Gateway joiner = new Gateway(false);

/* Это не реализация, а старая задумка, от которой я пока полностью не отказался. Боюсь
 * ни один разработчик не станет грамотно прописывать зависимости конвейеров друг от друга,
 * тем более что проявляться ошибки будут только в момент остановки системы. Потому текущий
 * вариант зависимости всего от всех в любом случае должен остаться, а возможность иерархии
 * отложить в долгий-долгий ящик, пока не появится явно тяжёлый проект с этой потребностью.
 * Каждый конвейер может находиться в следующем состоянии зависимости:
 * 1. Конвейер учавствует в зависимостях, от него есть зависимые конвейеры, но сам он
 *    ни от кого не зависит; он сразу получает команду остановки.
 * 2. Конвейер зависим от одного или нескольких других конвейеров; он получит команду
 *    остановки как только остановятся все конвейеры, от которых зависит он сам.
 * 3. Конвейер не учавствует в цепочке зависимостей; ему команда остановки отправляется
 *    только после остановки всех зависимых конвейеров.
 * 
 * При создании очередного конвейера, ему указываются зависимые от него конвейеры.
 * Зависимости сохраняются в обе стороны: каждый конвейер хранит конвейеры, от которых
 * он зависит и которые от него зависят. В случае досрочной остановки конвейера, цепочку
 * зависимостей нужно пересчитывать. Задачу можно создавать передавая в неё Manner. Тогда
 * у каждой задачи может быть одна из настроек: вызвать Shutdown обязательно, вызвать только
 * если задача в очереди, не нужно вызывать Shutdown. Также этот Manner можно назначать
 * и конвейерам, тогда он будет подхвачен задачей по умолчанию.
 * 1. Для упрощения отдельную остановку одного конвейера можно пока не реализовывать.
 * 2. Для упрощения иерархию зависимостей тоже можно пока не реализовывать.
 * 3. Также можно пока не хранить прикреплённые задачи.
 * 4. Пока можно вообще не оповещать задачи командой Shutdown.
 * -. Остаётся только подождать, когда все конвейеры опустошатся и послать им kill.
 * (пока так и сделано)
 * 
 * Размышление: спящие задачи можно не хранить и не уведомлять о завершении работы. Их можно
 * уведомить, если есть хотя бы один таймер, или если они попали потом в очередь. И вообще,
 * уведомлять о завершении работы можно только те задачи, которые попадают в очередь.
 * Но тогда неправильно будет отрабатываться задача Distributor/Statistic и подобные ей.
 * Тогда для таких задач можно отдельно регистрировать потребность в получении сигнала
 * Shutdown. */

	void add(AConveyor conveyor) {
		trace("Register " + conveyor.kindEx() + conveyor.name + '»');
		try { sync(); hash.add   (conveyor); } finally { unsync(); }
	}

	void remove(AConveyor conveyor) {
		trace("Release " + conveyor.kindEx() + conveyor.name + '»');
		try { sync(); hash.remove(conveyor); } finally { unsync(); } }

	/** Отправить сигнал, что один из конвейеров, которому был подан сигнал завершения работы,
	 * выполнил все задачи и готов завершить свою работу.
	 * @return true, если момент очистки всех конвейеров наступил, конвейеры заблокированы и
	 * текущий обработчик обязан сняв все синхронизации вызвать метод {@link #doKill()}. */
	@Synchronized void ready() throws Father.Trap {
		try { sync();
			if (awaiting == -1) throw new Trap();
			if (awaiting > 0) {
				if (--awaiting == 0) { push(Finished); throw new Trap(); }
			} else throw Illegal("Unexpected ready signal for destroy");
		} finally { unsync(); }
	}

	/** Очередной костыль. Я не могу вызвать этот алгоритм в методе ready, т.к. тот метод
	 * вызывает конвейер в режиме лёгкой синхронизации, а этот алгоритм должен вызываться
	 * кем-то так, чтобы синхронизации не было вообще. Поэтому этот метод вызывает тот же
	 * конвейер сняв всю синхронизацию, но только если ready вернёт true. */
	@Stable @Synchronized void doKill() {
//FIXME Проверить, что флаг уничтожения поднят!
		AConveyor[] array;
		try { sync();
			array = hash.toArray(new AConveyor[hash.size()]);
		} finally { unsync(); }

		try {
			for (AConveyor conveyor : array) conveyor.kill();
		} catch (Exception ex) {
			fault("Critical fail at the destroy phase of conveyor shutdown", ex);
		} finally { joiner.open(); }
	}

	/** Запрос конвейером разрешения отменить режим готовности к ликвидации и продолжить
	 * работу над вновь поступившей задачей в очередь исполнения. Если режим готовности
	 * будет отменён, то данный конвейер снова будет не готов завершить свою работу.
	 * @throws IllegalStateException — конвейеру нельзя отменить состояние готовности. */
	void unready() { try { sync();
		if (awaiting < 0) throw Illegal("Unexpected unready signal of a conveyor shutdown");
		if (awaiting == 0) throw ConveyorException.FailedWakeupBecauseShutdowning();
		++awaiting;
	} finally { unsync(); } }

	/** Запускает процесс завершения работы всей системы. Подаёт сигнал завершения работы
	 * всем Conveyor'ам. Ожидает, когда все конвейеры опустошат свои очереди исполнения.
	 * При опустошении посылает всем конвейерам команду kill, для ликвидации всех
	 * исполнительных * линий. */
	void shutdown() {
		info("All conveyors shutdown process starting...");
		AConveyor[] array;
		try { sync();
			array = hash.toArray(new AConveyor[hash.size()]);
			awaiting = array.length;
		} finally { unsync(); }
		joiner.close();
		for (AConveyor conveyor : array) conveyor.shutdown();
	}



	static final int fin = ABasket.fin-1;
	static final int Finished = 1<<fin+1;



	/** Ловушка Father'а для конвейеров. В момент, когда последний конвейер завершил свою
	 * работу и сообщил об этом Father'у, последний выбрасывает ловушку (исключение).
	 * Конвейер обязан перехварить эту ловушку в безопасном месте, усыпив последнюю линию
	 * и отменив все последующие действия, снять все блокировки и вызвать метод
	 * {@link Father#doKill()}. Тот метод вызовет метод {@link AConveyor#kill()} в каждом
	 * конвейере.
	 * <p/>Тут надо понимать хитрость/глупость. На самом деле все эти действия будет
	 * выполнять одна из линий одного из конвейеров — последняя активная линия. Пробуждение
	 * всех остальных линий было заблокировано в тот момент, когда данная последняя линия
	 * была помечена спящей. Тем не менее линия ещё не спит, она разблокирует конвейер,
	 * исполнит вызовы {@code #kill()} у всех конвейеров, и всем линиям будет отправлен
	 * сигнал распарковки. Только после этого линия вернётся в начальный цикл, увидит,
	 * что задач больше нет, и пойдёт на парковку. При попытке линии припарковаться система
	 * увидит, что был сигнал распарковки, сразу вернёт линии управления и тогда уже она
	 * пойдёт, как и все остальные, на очередной цикл, увидит, что задач нет, и завершит
	 * свою работу окончательно. */
	static final class Trap extends Exception { }
}


