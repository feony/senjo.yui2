/* Copyright 2018-2019, Senjo Org. Denis Rezvyakov aka Dinya Feony Senjo.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 */
package org.senjo.conveyor;

import static org.senjo.basis.Base.Illegal;
import static org.senjo.basis.Helper.unsafe;
import static org.senjo.basis.Text.*;

import java.util.PriorityQueue;
import org.senjo.annotation.*;
import org.senjo.basis.ABasketSync;
import org.senjo.conveyor.Entry.Waiting;
import org.senjo.conveyor.Line;
import org.senjo.support.Log;

/** Хранитель времени — специальная системная задача, следит и обслуживает все таймеры
 * конвейера.
 * <p/>Хранитель времени по особому использует конвейерную линию! Линия остаётся свободной
 * и в любой момент может быть передана внешней задаче, заметив это хранитель досрочно
 * освобождает линию: просто прекращает её использовать, забывает её и уводит на парковку,
 * т.к. при внешнем захвате считается, что линия спит и сигнал распарковки уже был
 * отправлен.
 * 
 * @author Denis Rezvyakov aka Dinya Feony Senjo
 * @version create 2018-01, change 2019-03-14, alpha */
final class TimeKeeper extends Unit {

	/** Очередь таймеров, которые ожидают времени своей активации. Очередь поддерживается
	 * сортированной по времени срабатывания. */
//TODO Переписать эту позорную реализацию PriorityQueue
	private final PriorityQueue<Waiting> queue = new PriorityQueue<>(Waiting.comparator);

	final Log log;
	/** Момент срабатывания самого ближайшего таймера в миллисекундах. */
	private long nextWakeup;

	private Line activeLine;

	TimeKeeper(AConveyor conveyor, Log log) { super(conveyor); this.log = log; }



//======== Служебные методы используемые конвейерной линией ==============================//
	@Synchronized @Override @Looper Unit process(Line line) { try { sync();
		/* Внутри данного метода, даже без блокировки, в парковке, может находиться строго
		 * только одна линия. Поэтому синхронизация по Keeper. */
		log.debug("keep: enter");
		long wakeup = nextWakeup;

		// Пока текущая линия активна: спим до таймера и пробуждаем наступившие таймеры
		while (line == activeLine) {
			// Припарковать линию и спать до пробуждения ближайшего назначенного таймера
			if (log.trace()) log.trace(
					wakeup > 0 ? "keep: park to " + textEpoch(wakeup) : "park infinite" );
			push(Parked); unsync(); line.park(wakeup); sync();
			log.debug("keep: unpark");
			// Если Parked не сняли раньше, то это штатное пробуждение, обработать таймеры
			wakeup = take(Parked) ?in_apply_lot(System.currentTimeMillis(), line) :nextWakeup;
		}

		Unit nextPlan = line.plan; line.plan = null;
		log.debug("keep: exit");
		return nextPlan;
	} catch (Throwable th) { log.fault("Critical fail of Time Keeper. ", th); return this;
	} finally { unsync(); } }

	/** Назначить исполнительную линию хранителю времени и обязать его наблюдать
	 * за таймерами самостоятельно. */
	@Synchronized @Lock(outer=AConveyor.class) void invoke(Line line) { try { sync();
		log.debug("keep: Assign " + hashName(line) + " to Time Keeper");
		if (this.activeLine == null) this.activeLine = line;
		else throw Illegal("Keeper assign failed, it already assigned");
	} finally { unsync(); } }

	/** Отозвать исполнительную линию у хранителя времени и освободить от обязанности
	 * наблюдать за таймерами самостоятельно. */
	@Synchronized @Lock(outer=AConveyor.class) long revoke(Unit plan) { try { sync();
		Line line = this.activeLine;
		log.debug("unkeep: Release " + hashName(activeLine) + " from Time Keeper");
		line.plan = plan;
		this.activeLine = null;
		if (take(Parked)) unsafe.unpark(line);
		return nextWakeup;
	} finally { unsync(); } }



//======== Внешние методы упраления таймерами ============================================//
/*XXX Добавить метод, который сначала проверит наступление таймера и если время ещё
 * не наступило, то вызовет #push(Timer). */

	/** Добавить таймер в очередь ожидания. При наступлении времени срабатывания таймер
	 * будет добавлен в задачу, а задача в очередь своего конвейера на обработку.
	 * При активации таймер удаляется из очереди. Повторяющиеся таймеры каждый раз должны
	 * возвращаться в очередь принудительно. Подразумевается, что пользователь не будет
	 * специально добавлять уже наступившие таймеры. Если время срабатывания таймера уже
	 * наступило, он всё равно будет помещён в очередь таймеров, сразу сработает сигнал
	 * наступления времени, другим потоком таймер будет извлечён из очереди и возвращён
	 * в задачу для обработки.
	 * <p/>Важно! Данный метод может вызывать синхронные методы конвейера, поэтому
	 * при вызове данного метода конвейер должен быть разблокирован. */
	@Synchronized(AConveyor.class) void push(Waiting timer) { try { sync();
		log.debug("keeper: Add timer at " + textEpoch(timer.instant));
		queue.offer(timer); checkWakeup();
	} finally { unsync(); } }

	/**
	 * <p/>Важно! Данный метод может вызывать синхронные методы конвейера, поэтому
	 * при вызове данного метода конвейер должен быть разблокирован. */
	@Synchronized(AConveyor.class) boolean take(Waiting timer) { try { sync();
		log.debug("keeper: Remove timer at " + textEpoch(timer.instant));
		if (queue.remove(timer)) { checkWakeup(); return true; }
		else return false;
	} finally { unsync(); } }



//======== Служебные методы контроля и пробуждения таймеров ==============================//
	@Synchronized long nextWakeup() {
		try { sync(); return nextWakeup; } finally { unsync(); } }

	/** Метод контроля после изменения очереди таймеров. Проверяет момент времени
	 * срабатывания ближайшего таймера. Если он изменился, то учитывает это. Разрешается
	 * не применять никаких действий, если время срабатывания не уменьшилось, а увеличилось,
	 * т.е. просто будет холостое срабатывание хранителя времени. */
	@Looper @Lock(inner=AConveyor.class) private final void checkWakeup() {
		Waiting nextTimer = queue.peek();
		long newWakeup = nextTimer != null ? nextTimer.instant : 0, oldWakeup = nextWakeup;
		if (oldWakeup == newWakeup) return; // Время ближайшего таймера не изменилось
		nextWakeup = newWakeup;

		Line line = this.activeLine;
		if (line != null) { // В хранителе времени задана линия, разбудить её если она спит
			/* Если время было, а теперь не задано или увеличилось, то не будем будить линию
			 * она позже проснётся в холостую по старому времени и сама пересчитает время
			 * ожидания. */
			if (oldWakeup != 0 && (newWakeup == 0 || oldWakeup < newWakeup)) return;
			if (take(Parked)) {
				if (log.trace()) log.traceEx("rekeep: Unpark signal to ")
						.hashName(line).end();
				unsafe.unpark(line); }
		} else {
			// Если хранитель был расформирован, то сбросить изменения и выйти.
			if (exist(Released)) { queue.clear(); nextWakeup = 0; return; }

			try { unsync(); line = conveyor.switchTimer(newWakeup); } finally { sync(); }
			// Если у конвейера нашлась свободная линия, то сразу назначить её и разбудить
			if (line != null) {
				if (log.debug()) log.debugEx("rekeep: Assign sleep ").hashName(line)
						.add(" to Time Keeper");
				this.activeLine = line; line.unpark(this); }
		}
	}

	/** Метод извлечения из очереди нескольких (не больше восьми) наступивших таймеров
	 * и возврат их в задачи на обработку. Вызывается лично конвейером в момент когда
	 * предполагается, что хотя бы один ближайший таймер уже наступил.<p/>
	 * @see TimeKeeper#in_apply_one(long)
	 * @param now — текущее системное время;
	 * @return время срабатывания следующего таймера; в результате ошибки ядра может
	 *         отличаться от {@link #nextWakeup} для небольшой задержки после сбоя. */
	@Synchronized(AConveyor.class) @Stable long apply(long now) { try { sync();
		log.debug("conv: Trigger the few timers");
		long wakeup = this.nextWakeup;
		int count = 8;
		while (0 < wakeup&&wakeup <= now) {
			wakeup = in_apply_one(now);
			if (--count == 0) break; }
		if (log.debug() && count == 8) log.debug("conv: Apply timer call is useless");
		return wakeup;
	} finally { unsync(); } }

	/** Метод извлечения из очереди множества наступивших таймеров и возврат их в задачи
	 * на обработку. Вызывается в момент когда предполагается, что хотя бы один ближайший
	 * таймер уже наступил. Метод только для хранителя, следит за активной линией и как
	 * только она поменяется, сразу прерывает работу и возвращает управление.<p/>
	 * @see TimeKeeper#in_apply_one(long)
	 * @param now — текущее системное время;
	 * @param currentLine — текущая линия, будет сравниваться с {@link #activeLine};
	 * @return время срабатывания следующего таймера; в результате ошибки ядра может
	 *         отличаться от {@link #nextWakeup} для небольшой задержки после сбоя. */
	@Looper private final long in_apply_lot(long now, @NotNull Line currentLine) {
		log.debug("keep: Trigger the lot timers");
		long wakeup = this.nextWakeup;
		while (0 < wakeup&&wakeup <= now) {
			wakeup = in_apply_one(now);
			if (currentLine != activeLine) break; }
		return wakeup;
	}

/*XXX Слишком много блокировок при множестве таймеров. Попробовать объединить
 * уже наступившие таймеры: изъять из очереди группу таймеров в массив, снять блокировку,
 * обработать группу таймеров, снова вернуться в блокировку Хранителя. */

	/** Метод извлечения из очереди гарантировано наступившего одного таймера и возврат его
	 * в задачу на обработку. Вызывается в тот момент когда известно, что этот ближайший
	 * таймер уже наступил. Может вызываться и конвейером напрямую, но перед этим конвейер
	 * обязан снять свою блокировку.<p/>
	 * Особый метод-перевёртыш, вызывается в режиме синхронизации, возвращает управление
	 * и результат строго в режиме синхронизации, чтобы в момент возврата никто не мог
	 * этот результат поменять, однако при этом внутри себя может снимать синхронизацию.
	 * @param now — текущее системное время;
	 * @return время срабатывания следующего таймера. */
	@Looper private final long in_apply_one(long now) {
		Waiting pollTimer = queue.poll(), peekTimer = queue.peek();
		nextWakeup = peekTimer != null ? peekTimer.instant : 0;

		try { unsync(); pollTimer.wakeup();
		} catch (Exception ex) { // Возможно, это лишняя проверка, после отладки убрать
			// Да-да, я читаю бит без синхронизации, но этот бит тут уже давно стоит
			if (exist(Released)) return 0;
			log.fault("Critical fail of wakeup the timer: ", ex);
			return now + 3_000;
		} finally { sync(); }
		return nextWakeup;
	}



//======== Basket : Константы для корзинки ===============================================//
	protected static final int fin = ABasketSync.fin-2;

	/** Исполнительная линия в настоящий момент задана и находится в спячке ожидая
	 * момента времени срабатывания ближайшего таймера. Эта линия хранится в поле
	 * {@link #activeLine}. Нужно понимать, что линия может быть задана, но при этом
	 * находиться в пробуждённом состоянии, тогда этот флаг будет снят. */
	private static final int Parked   = 1<<fin+1;
	/** Хранитель времени выключен. Это делается в момент подачи конвейеру сигнала
	 * {@link AConveyor#Shutdown}. В этом режиме хранитель сбрасывает все таймеры
	 * и молча игнорирует их дальнейшее добавление. */
	private static final int Released = 1<<fin+2;



	final int queueSize() { return queue.size(); }
}


/* Да-м. С хранителем времени творится настоящий каламбур.
 * 
 * Изначально его вообще не было и наблюдение за таймерами было внедрено прямо в конвейер.
 * Потом по мере роста кода конвейера данный механизм вытеснялся в отдельный класс. Потом
 * из-за упрощений и абстрагирования конвейерных линий превратился в отдельную задачу,
 * а то раньше линия тоже должна была понимать, с таймером она работает или
 * с пользовательской задачей.
 * 
 * В какой-то момент устоялся механизм, когда последняя конвейерная линия уходящая в спячку
 * засыпала не бессрочно, а до наступления времени срабатывания таймера. Но и тут возникли
 * сложности с определением причины пробуждения, а также с многопоточностью, какую линию
 * будить для обработки задачи: с таймером или бессрочную. Так родилась идея передавать
 * свободную исполнительную линию хранителю, чтобы он сам усыплял её на сколько нужно
 * и будил с её помощью таймеры, а в случае перегрузки линия отбиралась, а в конвейере
 * осталась только одна переменная времени и задача сравнивать это время с текущим. Это
 * позволило полностью убрать из линии код парковки с таймаутом. Также решилась
 * неопределённость в многопоточности, одна из линий была специальной и либо обслуживала
 * хранитель времени, либо пользовательские задачи.
 * 
 * Теперь мне не понравилось, что все наследники-реализации конвейера вынуждены знать,
 * учитывать и обслуживать особую конвейерную линию. В случае чего эту линию нужно назначать
 * и освобождать хранителю времени, а также для упрощения эта конвейерная линия обязательно
 * должна была создаваться сразу даже для пустого хранителя, т.е. когда она ещё и не нужна,
 * а возможно вообще никогда и не понадобится. По-началу это всё казалось эффективным, ведь
 * наследник просто по индексу и по своему флагу может определить, является ли линия
 * гибридной, и обработать её немного иначе. Также наследник легко мог управлять флагами
 * Idle и Load, т.к. понимал момент, когда все линии становились условно свободными или
 * занятыми. Однако логически это явно неверно, почему наследник должен заниматься вещами
 * явно относящимися к абстракции.
 * 
 * Хотелось бы устранить захват линии хранителем времени, т.е. просто одной из линий
 * назначать парковку с таймаутом: если она просыпается по таймауту, то берёт задачу
 * хранителя, иначе ей назначается задача пользователя и она пробуждается досрочно.
 * Однако возможен конфликт, когда линия одновременно просыпается по таймауту, успевает
 * забрать задачу хранителя и ей назначается задача пользователя.
 * 
 * Попытался я реализовать прозрачный и неявных алгоритм перехвата линии и вернулся к старой
 * идеологии. Основные проблемы:
 * 1) Неявность и неконкретность. Когда пытаешься понять код, где какое состояние, возникает
 *    неприятное чувство. Серьёзно, везде присутствует состояние неопределённости, и его
 *    нужно учитывать. Когда базис не знает про хранителя, программист не знает и проблем.
 * 2) Неэффективный однопоточный конвейер. При срабатывании таймера, хранитель своей линией
 *    его будит. Таймер требует у конвейера выполнить задачу. Конвейер отбирает линию
 *    у хранителя, причём неявно, не предупреждая об этом хранителя. Причём из-за неявности
 *    конвейер не знает, назначена ли линия хранителю, он просто назначает в линию задачу
 *    и будет её. Управление возвращается хранителю, тот обязан проверить, не отобрали ли
 *    линию, а если её отобрали, то уже и разбудили, тогда хранитель просто завершает свой
 *    process-метод. Линия уходит в спячку, тут же просыпается и штатно обрабатывает задачу.
 *    А т.к. в простом конвейере линия единственная, то каждое срабатывание таймера ведёт
 *    к двойному пробуждению и засыпанию линии. В старом методе пробуждение единственное.
 */


